# -*- coding: utf-8 -*-
"""githubtryingapp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1L_hChAkz7594G8V41Kn3x9k8JEII20DW
"""

import os
import tempfile
from flask import Flask, request, jsonify
from flask_cors import CORS
import joblib
import numpy as np
import pandas as pd
import parselmouth

# ==== 1. INIT ====
app = Flask(__name__)
CORS(app)  # Allow requests from your frontend domain

# ==== 2. LOAD MODEL ====
MODEL_PATH = "rf_model.pkl"
FEATURE_COLS = [
    'MDVP:Fo(Hz)', 'MDVP:Fhi(Hz)', 'MDVP:Flo(Hz)',
    'MDVP:Jitter(%)', 'MDVP:Jitter(Abs)', 'MDVP:RAP', 'MDVP:PPQ', 'Jitter:DDP',
    'MDVP:Shimmer', 'MDVP:Shimmer(dB)', 'Shimmer:APQ3', 'Shimmer:APQ5', 'MDVP:APQ', 'Shimmer:DDA',
    'NHR', 'HNR'
]

rf_model = joblib.load(MODEL_PATH)

# ==== 3. FEATURE EXTRACTION ====
def extract_features_parselmouth(wav_path):
    snd = parselmouth.Sound(wav_path)
    features = {}
    try:
        pitch = snd.to_pitch()
        features['MDVP:Fo(Hz)'] = np.nanmean(pitch.selected_array['frequency'])
        features['MDVP:Fhi(Hz)'] = np.nanmax(pitch.selected_array['frequency'])
        features['MDVP:Flo(Hz)'] = np.nanmin(pitch.selected_array['frequency'])
        point_process = snd.to_point_process_cc()
        features['MDVP:Jitter(%)'] = snd.to_jitter_local()
        features['MDVP:Jitter(Abs)'] = snd.to_jitter_local_absolute()
        features['MDVP:RAP'] = snd.to_jitter_rap()
        features['MDVP:PPQ'] = snd.to_jitter_ppq5()
        features['Jitter:DDP'] = snd.to_jitter_ddp()
        features['MDVP:Shimmer'] = snd.to_shimmer_local()
        features['MDVP:Shimmer(dB)'] = snd.to_shimmer_local_dB()
        features['Shimmer:APQ3'] = snd.to_shimmer_apq3()
        features['Shimmer:APQ5'] = snd.to_shimmer_apq5()
        features['MDVP:APQ'] = snd.to_shimmer_apq5()  # Use APQ5 if APQ not available
        features['Shimmer:DDA'] = snd.to_shimmer_dda()
    except Exception:
        for col in FEATURE_COLS:
            features[col] = np.nan

    try:
        features['NHR'] = snd.to_noise_harmonics_ratio()
    except Exception: features['NHR'] = np.nan
    try:
        features['HNR'] = snd.to_harmonics_noise_ratio()
    except Exception: features['HNR'] = np.nan

    # Fill missing features
    for col in FEATURE_COLS:
        if col not in features:
            features[col] = np.nan

    df = pd.DataFrame([features])[FEATURE_COLS]
    return df

# ==== 4. PREDICT ENDPOINT ====
@app.route("/predict", methods=["POST"])
def predict():
    # Check file in request
    if "file" not in request.files:
        return jsonify({"error": "No file part in request"}), 400
    file = request.files["file"]
    if file.filename == "":
        return jsonify({"error": "No file selected"}), 400

    # Save file to temp location
    with tempfile.NamedTemporaryFile(delete=False, suffix=".wav") as tmp_wav:
        file.save(tmp_wav.name)
        wav_path = tmp_wav.name

    # Extract features
    try:
        feats = extract_features_parselmouth(wav_path)
        if feats.isnull().any(axis=None):
            os.remove(wav_path)
            return jsonify({"error": "Failed to extract all features from audio. Try recording again."}), 400

        # Predict probability and class
        prob = rf_model.predict_proba(feats)[0, 1]
        THRESHOLD = 0.63
        pred = int(prob > THRESHOLD)
        diagnosis = "Likely Parkinson's Disease" if pred == 1 else "Likely Healthy"

        os.remove(wav_path)
        return jsonify({
            "result": diagnosis,
            "probability": round(float(prob), 3),
            "threshold": THRESHOLD
        })
    except Exception as e:
        os.remove(wav_path)
        return jsonify({"error": f"Feature extraction or prediction failed: {str(e)}"}), 500

# ==== 5. HEALTH CHECK ====
@app.route("/")
def index():
    return "Parkinson's Voice Classifier Backend Running!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=10000)